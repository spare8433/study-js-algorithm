<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      function solution(n, m) {
        let answer = [];

        // arr : 현재 까지의 구슬 집합을 의미할 배열 인자, count : 총 구슬 나열 횟수를 의미할 인자
        // 위 파라미터를 가지고 구슬 집합을 채워가는 재귀함수 DFS 선언
        function DFS(arr = [], count = 0) {
          // m 번까지 모두 뽑은 상황에서 현재 arr 배열을 정답배열에 추가
          if (count === m) {
            answer.push(arr);
          } else {
            // 현재 arr 배열에 i 값을 추가한 배열을 인자로 DFS 함수를 재귀적으로 호출
            for (let i = 1; i <= n; i++) {
              DFS([...arr, i], count + 1);
            }
          }
        }

        // 보완가능 부분
        // count 인자 필요없이 배열의 길이로 사용해도 동일하게 작동
        // function DFS(arr = []) {
        //   if (arr.length === m) {
        //     answer.push(arr);
        //   } else {
        //     for (let i = 1; i <= n; i++) {
        //       DFS([...arr, i]);
        //     }
        //   }
        // }

        DFS();
        return answer;
      }

      // 정답지 방법
      //   function solution(n, m) {
      //     let answer = [];
      //     // 현재 구슬 집합을 의미할 길이가 m 이고 0 으로 채워진 배열 tmp 생성
      //     let tmp = Array.from({ length: m }, () => 0);

      //     // 뽑을 공의 순서를 의미할 인자 L 을 가지고 구슬 집합을 채워가는 재귀함수 DFS 선언
      //     function DFS(L) {
      //       // m 번까지 모두 뽑은 상황에서 현재 tmp 배열을 정답배열에 추가
      //       if (L === m) {
      //         answer.push(tmp.slice());
      //       } else {
      //         // tmp 배열에 L 번째 값을 반복문안에서 i 값으로 변경 후 L + 1 값을 매개변수로 DFS 함수를 재귀적으로 호출
      //         for (let i = 1; i <= n; i++) {
      //           tmp[L] = i;
      //           DFS(L + 1);
      //         }
      //       }
      //     }

      //     DFS(0);
      //     return answer;
      //   }

      console.log(solution(3, 2));
    </script>
  </body>
</html>
