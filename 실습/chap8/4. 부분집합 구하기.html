<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      // 문제 해설 참고한 코드
      function solution(n) {
        let answer = [];

        function DFS(L, str = "") {
          // 모든 원소를 거친 이후 문자열을 정답 배열에 추가
          if (L > n) return str && answer.push(str);

          // 현재 값 L 포함된 부분집합의 경우로 L 값이 추가된 문자열을 재귀 함수로 처리
          DFS(L + 1, str + L);

          // 현재 값 L 포함되지 않은 부분집합의 경우로 L 값이 포함되지 않은 문자열을 재귀 함수로 처리
          DFS(L + 1, str);
        }
        DFS(1);
        return answer;
      }

      // 정답지 방법

      // 재귀함수가 마무리 되고 최종 정답 배열을 반환
      function solution(n) {
        let answer = [];
        // n + 1 길이의 체크 배열(ch)을 생성하고 0 으로 모두 초기화
        // (값이 0 : 원소가 부분집합에 있지 않은 경우, 값이 : 1 원소가 부분집합에 있는 경우)
        let ch = Array.from({ length: n + 1 }, () => 0);

        // 현재 원소 L 값이 현재 원소값 L 이 n + 1 이 되는 경우 재귀함수를 종료

        function DFS(L) {
          if (L === n + 1) {
            let tmp = "";

            // ch[L] 값이 1인 경우 그 배열의 인덱스값을 문자열(tmp)에 추가하며
            for (let i = 1; i <= n; i++) {
              if (ch[i] === 1) tmp += i + " ";
            }

            // 문자열이 비어있는 경우 즉 공집합인 경우를 제외하고 최종적으로 완성된 문자열을 배열에 추가
            if (tmp.length > 0) answer.push(tmp.trim());
          }
          // 체크 배열에 L번째(ch[L]) 값이 0인 경우와 1인 경우로 나누어 재귀 함수 호출
          else {
            ch[L] = 1;
            DFS(L + 1);
            ch[L] = 0;
            DFS(L + 1);
          }
        }
        DFS(1);
        return answer;
      }

      console.log(solution(3));
    </script>
  </body>
</html>
