<html>
  <head>
    <meta charset="UTF-8" />
    <title>출력결과</title>
  </head>
  <body>
    <script>
      //   function solution() {
      //     let answer = ""; // 탐색한 노드들의 순서를 문자열로 저장할 정답 변수

      //     // 너비 우선 탐색을 처리할 재귀함수
      //     // num : 현재 레벨의 가장 낮은 수를 의미하는 인자
      //     // level : 현재 트리에서 탐색할 노드의 레벨을 의미하는 인자
      //     function BFS(num, level) {
      //       // 현재 레벨에 존재하는 제일 큰 마지막 수(레벨^2 - 1 ) 를 변수 last 에 저장
      //       let last = 2 ** level - 1;

      //       // 현재 레벨의 가장 낮은 수의 노드부터 가장 높은 수의 노드까지 반복
      //       for (let i = num; i <= last; i++) {
      //         if (i > 7) return; // 7 을 넘어가는 노드의 경우 노드를 탐색하지 않고 함수 종료
      //         answer += i + " "; // 탐색한 노드를 정답 변수에 문자열 추가
      //       }
      //       console.log(level, answer);

      //       // 현재 레벨의 마지막 노드에 + 1 값이 다음 레벨의 가장 낮은 노드 숫자와 다음 레벨을 매개변수로 BFS 함수를 재귀적으로 호출
      //       BFS(last + 1, level + 1);
      //     }

      //     BFS(1, 1); // 1 노드, 1 레벨 부터 시작
      //     return answer;
      //   }

      //   console.log(solution());

      // 정답지 방법
      function solution() {
        let answer = "";
        let queue = [];
        queue.push(1); // 첫번째 노드 삽입

        // 큐가 모두 비워질 때까지 반복
        while (queue.length) {
          console.log(queue);

          // 현재 큐에 맨 앞있는 노드를 탐색한 것으로 보고 큐에서 제외
          let v = queue.shift();
          answer += v + " ";

          // 탐색 완료된 노드에 하위 노드가 있다면 존재할 2 개의 숫자들(v * 2, v * 2 + 1)을 순서대로 반복
          // 하위 노드가 있는 존재하는 노드의 겨웅 하위 노드를 큐에 추가  ex) 2 노드를 탐색한 경우 4,5 노드 추가
          for (let nv of [v * 2, v * 2 + 1]) {
            // 7이 넘어가는 수는 하위 노드가 존재할 수 없으므로 하위노드 생성과정을 생략
            if (nv > 7) continue;

            queue.push(nv); // 하위 노드를 큐에 추가
          }
        }
        return answer;
      }

      console.log(solution());
    </script>
  </body>
</html>
